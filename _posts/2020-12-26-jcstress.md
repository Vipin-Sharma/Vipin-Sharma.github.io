---
layout:     post
title:      "JCStress"
subtitle:   "Java Concurrency Stress"
date:       2020-12-26 00:00:00
author:     "Vipin Sharma"
header-img: "img/posts/blog-post-bg2.jpeg"
comments: true
tags: [OpenJDK, jcstress]
---

Draft (Work in progress)

### What is JCStress:

<!--The JCStress is the experimental harness and a suite of tests to aid the research in the correctness of concurrency support in the JVM, class libraries, and hardware.-->

Concurrent code is hard to test, it is possible some code works for years and one bad day it fails. 
For this JCStress is a stress test framework for concurrent programs developed by JDK developers.


### Starting with first JCStress test

Following are important annotations to understanding JCStress APIs used in our basic test.

@Actor			: It annotates methods that hold the actions done by the threads.

<!-- The invariants that are maintained by the infrastructure are as follows:
 
	Each method is called only by one particular thread.
	Each method is called exactly once per {@link State} instance.

Note that the invocation order against other {@link Actor} methods is deliberately not specified.
Actions in Actor annotated method is executed by thread and thread has access to @State and @Result.-->

@State 			: It annotates the class that holds the data mutated/read by the tests.

@Result			: This annotation marks the result object.

@JCStressTest	: Mark the class as JCStress test.

@Outcome		: It describes the test outcome, and how to deal with it. 
<!--Some possible  outcome is ACCEPTABLE, ACCEPTABLE_INTERESTING, FORBIDDEN.-->

This is basic test to show how different JCStress API components are used to create stress test.

```java
@JCStressTest

// These are the test outcomes.
@Outcome(id = "1, 1", expect = Expect.ACCEPTABLE_INTERESTING, desc = "Both actors came up with the same value: atomicity failure.")
@Outcome(id = "1, 2", expect = Expect.ACCEPTABLE, desc = "actor1 incremented, then actor2.")
@Outcome(id = "2, 1", expect = Expect.ACCEPTABLE, desc = "actor2 incremented, then actor1.")

// This is a state object
@State
public class APISample_01_Simple {

    int v;

    @Actor
    public void actor1(II_Result r) {
        r.r1 = ++v; // record result from actor1 to field r1
    }

    @Actor
    public void actor2(II_Result r) {
        r.r2 = ++v; // record result from actor2 to field r2
    }

}
```

Following are few important points about the above test:

1. State object has field int v, where state of the test is stored.

2. II_Result is Result annotated class, which has 2 int fields r1 and r2.

3. For each test executed, 2 threads run actor1 and actor2 for same instance and record result in same instance of II_Result.

4. End of test Outcome is checked on basis of Result instance variables, which are 2 integers in this case. Depending upon output of test we tag it with corresonding Expect value, e.g. for r1=1 and r2=2, result is Expect.ACCEPTABLE.

<br>

### How to run JCStress test
todo, create project on github for this.

### More JCStress APIs

JCStress provides enough useful APIs to develop Java concurrency tests. This sections we are going to discuss these APIs and how they solve different type of problems.

#### Using Result classes in JCStress
JCStress ships lots of pre-canned result classes. e.g. II_Result and III_Result, here I represent an int.
Similarly, following is list of different letters used in JCStress result classes.

    I 	: 	int
    Z 	: 	boolean
    F	:	float
    J	:	long
    S	: 	short
    B	:	byte
    C	:	char
    D	:	double
    L	:	object

With help of this we can try to find pre canned Result class in JCStress.
e.g 
1. for Result having int(I) and boolean(Z) we need IZ_Result.
2. for Result having float(F) and long(J) we need FJ_Result.

#### Arbiters
Method annotated with @Arbiter run after all method annotated with @Actor, and therefore can observe the final result. [This](https://github.com/openjdk/jcstress/blob/master/jcstress-samples/src/main/java/org/openjdk/jcstress/samples/APISample_02_Arbiters.java) is sample test using Arbiters.

#### Signal
Signal is useful for delivering a termination signal to Actor in Mode.Termination tests. It will run after Actor in question started executing. For termination test we use annotation @JCStressTest(Mode.Termination).
[This](https://github.com/openjdk/jcstress/blob/master/jcstress-samples/src/main/java/org/openjdk/jcstress/samples/APISample_03_Termination.java) is sample test using Signal.



#### Nested tests
It is sometimes convenient to put the tests in the same source file for better comparison. JCStress allows to nest the tests. [This](https://github.com/openjdk/jcstress/blob/master/jcstress-samples/src/main/java/org/openjdk/jcstress/samples/APISample_04_Nesting.java) is sample test showing nested tests in JCStress.

#### Shared Metadata
When tests share the outcomes and other metadata. To use common metadata for such tests, there is a special @JCStressMeta annotation that can use metadata of another class.
[This](https://github.com/openjdk/jcstress/blob/master/jcstress-samples/src/main/java/org/openjdk/jcstress/samples/APISample_05_SharedMetadata.java)

#### Adding test descriptions and references
JCStress also allows to put the descriptions and references right at the test. This helps to identify the goal for the test, as well as the discussions about the behavior in question.

Following is example showing how we can add test descriptions and references

@Description("Sample Hello World test")

@Ref("http://openjdk.java.net/projects/code-tools/jcstress/")

<br>

### Conclusion

Knowing language features like this helps you get the best java jobs, that's why to help you I wrote ebook [5 steps to Best Java Jobs](https://jfeatures.com/). Download this step by step guide for free!

[<img src="../img/ebook_upd.png" width="200" height="200">](https://jfeatures.com/)

Resources:
