---
layout:     post
title:      "Hidden classes"
subtitle:   "Java 15 feature"
date:       2020-09-13 01:00:00
author:     "Vipin Sharma"
header-img: "img/posts/blog-post-bg2.jpeg"
comments: true
tags: [java, JDK15]
---

The initial draft, work in progress.

<!-- Attention -->
### What are Hidden classes in Java ?
Classes that cannot be used directly by the bytecode of other classes, are hidden classes.


Hidden classes allow frameworks/jvm languages to define classes as 
non-discoverable implementation details, so that they ***cannot*** be linked against 
by other classes nor discovered through reflection.


<!--
Deprecate the non-standard API sun.misc.Unsafe::defineAnonymousClass, with the 
intent to deprecate it for removal in a future release. -->


Many language implementations built on the JVM rely upon dynamic class generation 
for flexibility and efficiency. 
Before JDK15 dynamic classes were generated using non-standard API sun.misc.Unsafe::defineAnonymousClass, 
now with introduction of hidden classes as standard feature in java language this method is deprecated.

Best example is lambda expressions in Java language.
JDK developers don't want to expose classes generated by lambda expression so
javac is not translating lambda expression into dedicated class, it generates 
bytecode that dynamically generates and instantiates a class to yield an object
corresponding to the lambda expression when needed.

<br>

<!-- Interest -->
### Why hidden classes are required in Java?

Framework/Language implementors usually intend for a dynamically generated class to be 
logically part of the implementation of a statically generated class. 
For this intent following are properties that are desirable for dynamically generated classes:


1. Non-discoverability.
Dynamic generated classes should not be discoverable by other classes in JVM.
(e.g. using Class::forName and ClassLoader::loadClass)


2. Access control. 
It may be desirable to extend the access control context of the statically 
generated class to include the dynamically generated class.

3. Lifecycle. Dynamically generated classes may only be needed for a limited time, 
so retaining them for the lifetime of the statically generated class might 
unnecessarily increase memory footprint. Existing workarounds for this situation, 
such as per-class class loaders, are cumbersome and inefficient.


Existing APIs ClassLoader::defineClass and Lookup::defineClass, always define 
a visible class, and in this way classes have longer lifecycle than desired.

Hidden classes have different handling of classloaders, that makes it non
    discoverable to other classes.

Hidden classes support extending an access control nest.
A hidden class can be created as a member of an existing nest by passing the 
NESTMATE option to Lookup::defineHiddenClass.

Hidden class is created by invoking Lookup::defineHiddenClass. 
    This causes the JVM to derive a hidden class from the supplied bytes, 
    link the hidden class, and return a lookup object that provides reflective 
    access to the hidden class.
    The invoking program should store the lookup object carefully, 
    for it is the only way to obtain the Class object of the hidden class.      

<br>

<!-- Desire -->
### Creating Hidden class demo

<!--
A hidden class specific way to have a defining class loader. 
This is necessary to resolve types used by the hidden class's own fields and methods. 
In particular, a hidden class has the same defining class loader, runtime package, 
and protection domain as the lookup class, which is the class that originally 
obtained the lookup object on which Lookup::defineHiddenClass is invoked. 
-->


```java
public class HiddenClassDemo {
    public static void main(String[] args) throws Throwable {
        MethodHandles.Lookup lookup = MethodHandles.lookup();
        ClassWriter cw =
                GenerateClass.getClassWriter(HiddenClassDemo.class);
        byte[] bytes = cw.toByteArray();

        Class<?> c = lookup.defineHiddenClass(bytes, true, NESTMATE).lookupClass();
        Constructor<?> constructor = c.getConstructor(null);
        Object object = constructor.newInstance(null);
        Test test = (Test) object;
        test.test(new String[]{""});
        System.out.println("End of main method in class " + HiddenClassDemo.class.getName());
    }
}

```

```java
public static ClassWriter getClassWriter(Class<HiddenClassDemo> ownerClassName) {
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);

        cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, getHiddenClassName(ownerClassName),
                null, "java/lang/Object", new String[] {"com/vip/jfeatures" +
                        "/jdk15/hiddenclass/Test"});

        ...
        ...
        ...

            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, "test",
                                "([Ljava/lang/String;)V", null, null);
            mv.visitCode();
            mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
            mv.visitLdcInsn("Hello test");
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V");
            mv.visitInsn(RETURN);
            mv.visitMaxs(2, 1);
            mv.visitEnd();        

    }
```


<br>

### At the end

To learn the best java language features download my ebook [ðŸ”¥***5 steps to Best Java Jobs***ðŸ”¥](https://jfeatures.com/) for Free.

Follow me on twitter [ðŸ”¥***@vipinbit***ðŸ”¥](https://twitter.com/vipinbit) to get daily tips like this on Java Language Features.

### Resources
1. https://openjdk.java.net/jeps/371, This is Java enhancement proposal for Hidden classes in JDK15.
2. https://github.com/Vipin-Sharma/JDK15Examples, this is link to code examples used in this post.